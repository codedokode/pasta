# Зачем нужно Dependency Injection (и что это?)

В этом уроке мы разберемся с тем, что такое зависимости классов и внедрение зависимостей. Пожалуйста, помните, что все описанные здесь принципы появились не просто так. Мы используем их не потому, что слепо в них верим, а потому что они помогают решить проблемы, стоящие при разработке больших приложений. Начнем издалека.

## Принцип одной обязанности

Главная проблема больших приложений в том, что с ростом объема кода становится гораздо сложнее в нем разбираться, легче допустить ошибку и, как следствие, разработка замедляется. Для борьбы с этим используется разделение ответственности («разделяй и властвуй») - мы разбиваем сложную задачу (например, задачу регистрации пользователей) на небольшие, независимые части: вывод формы регистрации, прием данных из формы, проверка информации, сохранение ее в базу данных, авторизация пользователя. Каждой из этих подзадач соответствует отдельный метод или класс. 

[Принцип единственной обязанности](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%B5%D0%B4%D0%B8%D0%BD%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D0%B9_%D0%BE%D0%B1%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8) заключается в том, что каждый класс занимается только своим делом. Например, один класс отвечает только за взаимодействие с БД, другой за проверку правильности введенных данных, третий за выставление и проверку кук для авторизованных пользователей. 

Теперь, если мы хотим понять, как происходит например проверка данных при регистрации, или что-то в ней поменять, нам надо изучить лишь один класс, который этим занимается. Также, мы можем протестировать процесс проверки отдельно от остального кода (более того, мы можем его тестировать даже если остальные методы пока не написаны).

## Зависимости

Если мы разбили код на классы, то может оказаться, что одному из них нужен другой. Ну например, если у нас есть класс авторизации, а в нем метод, проверяющий логин и пароль пользователя на правильность, которые хранятся в базе данных, ему понадобится класс, достающий их оттуда. 

В таких случаях говорят, что класс `A` зависит от класса `B`, или `B` является *зависимостью* (dependency) класса `A`. 

Зависимости бывают обязательные (без которых класс работать не может), и необязательные. Пример необязательной зависимости - это класс-логгер. Он может быть нужен только при отладке кода, а на боевом сервере не требуется.

Теперь обсудим, в чем вред от глобальных переменных и злоупотребления статическими методами, чтобы у тебя не возникло даже мысли использовать их для связи классов между собой. А после узнаем про правильный способ внедрения зависимостей.

## Чем плохи глобальные переменные

Глобальная переменная - это переменная, которая всегда существует в одном экземпляре и доступна из любого места кода. Статические поля классов тоже существуют в одном экземпляре, потому их можно рассматривать как разновидность глобальной переменной. 

На первый взгляд они хорошо подходят для хранения таких вещей, как: настройки (например имя и пароль к базе данных), или язык выводимых сообщений на многоязычном сайте, но если присмотреться, то это почти всегда плохое решение.

То, что глобальная переменная доступна из любого места кода - это плохо. Это значит, что при изменении кода, связанном с этой переменной, нам придется делать поиск по всему коду и изучать каждый случай использования. Чем меньше область, где доступна переменная, тем проще поменять работающий с ней код. В случае с настройками базы данных, достаточно передать их только в класс, отвечающий за соединение с ней. 

Также, доступная глобально переменная (например, настройки базы данных) провоцирует неопытных программистов писать код работы с базой данных в любом месте программы, вместо того, чтобы сконцентрировать его в одном классе. 

Глобальные переменные создают нежелательные побочные эффекты. Допустим, у нас есть многоязычный сайт, работающий на 2 доменах (`example.com` на английском и `example.ru` на русском). В начале обработки запроса мы по названию домена определяем язык пользователя и сохраняем в глобальную переменную `$language`. А различные функции в зависимости от ее значения возвращают результат на нужном языке. Ну например, метод отправки письма об успешной регистрации пользователю выглядит так: 

```php
public function sendRegistrationMessage($userEmail) 
```

Глядя на заголовок, невозможно догадаться что на результат его работы влияет еще и `$language`. И когда мы захотим вызвать эту функцию, не задав перед этим значение глобальной переменной, мы получим ошибку. Или хуже, письмо отправится, но на неправильном языке. А если мы помним про переменную, и поменяем ее значение перед вызовом метода, то повлияем на работу всех остальных методов. 

В этой ситуации код был бы понятнее, если бы язык указывался явно в аргументах функции, либо передавался через конструктор класса, в котором находится метод. 

Как я уже писал выше, статические поля в классах зачастую аналогичны глобальным переменным. Они точно так же добавляют побочные эффекты в использующие их функции.

## Чем плохи статические методы

Недостатки статических методов: 

- нельзя создать 2 объекта с немного разными настройками. Ну например, нельзя создать 2 класса-валидатора, выдающих сообщения об ошибке на разных языках, нельзя создать объект, работающий с другими настройками базы данных. Нельзя создать временный объект, попользоваться и выбросить его, не повлияв на остальной код.
- статические методы не могут обращаться к `$this`, и могут хранить данные только в статических полях, которые по сути аналогичны глобальными переменным, и их изменение влияет на весь остальной код. 
- связи между классами жестко прописаны в коде. Когда один класс `A` вызывает статический метод другого класса `B`, мы не можем как-то указать классу `A` использовать класс `C` вместо `B`.
- связи между классами не очевидны. Чтобы понять, что класс `A` использует класс `B`, надо изучить его код целиком. Мы не можем определить это только по конструктору или заголовкам методов.

Допустим, что мы сделали метод проверки правильности данных пользователя статическим. Он принимает на вход объект пользователя и возвращает массив сообщений об ошибках: 

```php
class UserValidator
{
    public static function validate(User $user) { ... }
}
```

Далее, мы пишем метод регистрации пользователя, который в том числе вызывает метод валидации: 

```php
class RegistrationService
{
    public static function register(User $user)
    {
        $errors = UserValidator::validate($user);
        ...
    }
}
```

Теперь мы хотим добавить проверку, что email пользователя уникальный и не принадлежит другому зарегистрированному пользователю. Для этого классу `UserValidator` надо обратиться к базе данных. Но как ему получить объект `UserTableGateway`, который содержит методы поиска в таблице пользователей? Нам придется либо передавать его как аргумент в `validate()` (а значит и в `register()`), либо хранить где-то в статическом поле класса `UserValidator`. В первом случае нам приходится править оба класса вместо одного (хотя `RegistrationService` не занимается валидацией). Во втором мы получаем глобальную переменную и побочные эффекты. 

Код на статических методах - это не ООП код, это по сути процедурный спутанный код из функций. По мере роста приложения вносить в него изменения будет все сложнее.

Однако, иногда лучше использовать именно статические методы. Они подходят для простых функций, не привязанных ни к какому объекту, не использующих поля класса, результат которых зависит только от переданных аргументов. Например, функция перевода градусов в радианы, функция, генерирующая случайный пароль или определяющая расширение по имени файла. Если такую функцию нельзя отнести к какому-то классу, ее помещают в вспомогательный класс с названием вроде `Util`, `StringUtil` или `MathUtil` (паттерн Utility Class).

Также, статические методы можно использовать как дополнительные конструкторы в классе (паттерн Static Constructor).

## Внедрение зависимостей

*Внедрение зависимостей* (dependency injection) - это передача зависимостей в класс снаружи. Внедрять их можно через конструктор или отдельный метод.

Хорошая функция получает нужные ей значения через аргументы, а хороший класс получает свои обязательные зависимости через конструктор. Это имеет такие преимущества: 

- нельзя забыть передать зависимость при создании класса
- зависимости легко увидеть, глянув на конструктор
- мы выбираем, какую зависимость с какими настройками передать
- можно создать несколько объектов с разными настройками
- можно передать в качестве зависимости не только требуемый класс, но и его наследника, с измененным нами поведением

Необязательные зависимости обычно либо передают через отдельный метод-сеттер (вроде `setLogger(Logger $logger)`), либо через конструктор с указанием `null` в качестве значения по умолчанию.

Вот пример передачи зависимостей классу-валидатору: 

```php
class UserValidator
{
    public function __construct(UserTableGateway $userTableGateway) { ... }
    public function setLogger(Logger $logger) { ... }
    ...
}
```

А вот пример того, как мы можем создать 2 разных валидатора, использующих разные объекты работы с БД, один - настоящий, а другой - тестовый, который возвращает заранее подготовленные данные. Эти валидаторы полностью независимы друг от друга и не влияют на остальной код: 

```php
$realUserTableGateway = new UserTableGateway(...);
$realValidator = new UserValidator($realUserTableGateway);

$testUserGateway = new TestUserGateway();
$testValidator = new UserValidator($testUserGateway);
```

Как мы видим, внедрение зависимостей дает нам максимальную гибкость использования и позволяет сделать классы слабо связанными друг с другом, так, что изменение в одном не потребует переделки другого.

В данном случае `TestUserGateway` должен быть наследником `UserTableGateway`, чтобы пройти проверку в тайп-хинте. Чтобы избежать необходимости применять наследование, мы можем добавить интерфейс `UserTableGatewayInterface` и указать его как тайп-хинт. Это называется «внедрение зависимости через интерфейс», и в большинстве случаев это не требуется.

Поскольку тут зависимости передаются снаружи, а не класс сам ищет их, это называется *инверсия управления* (IoC, inversion of control). Такой подход дает нам максимальную гибкость в том, как создавать и связывать между собой объекты разных классов.

Увы, иногда можно встретить менее удачные способы получения зависимостей. Разберем их недостатки.

## Registry и чем он плох

[Registry (*реестр*)](http://design-pattern.ru/patterns/registry.html) - это класс, как правило, со статическими методами, который хранит в себе другие объекты. В начале скрипта мы помещаем объекты в `Registry`, и затем другие классы могут оттуда их брать. Как правило, класс Registry доступен глобально, из любой точки кода, за счет использования статических методов. Например: 

```php
// Создаем и помещаем зависимость в registry
// Объект соединения с БД
$pdo = new PDO(...);
Registry::setPdo($pdo);

// Класс работы с таблицей пользователей
$userDataGateway = new UserDataGateway;
Registry::setUserDataGateway($userDataGateway);

$validator = new UserValidator;
Registry::setValidator($validator);
```

Когда классу `UserValidator` нужно что-то получить из БД, он находит объект для работы с ней в `Registry`:

```php
class UserValidator
{
    public function validate(User $user)
    {
        $udg = Registry::getUserDataGateway();
        if ($udg->isEmailInDb($user->email)) {
            ...
```

Недостатки Registry:

- классы связаны намертво и подменить или настроить зависимости одного класса нельзя. `Registry` это по сути набор глобальных переменных и статических методов со всеми их недостатками.
- зависимости класса не видны явно. Непонятно без изучения кода, что надо положить в `Registry`, чтобы этот конкретный объект работал.
- у всех классов появляется лишняя зависимость от класса `Registry`. Их не получится использовать без него. Я бы сказал, что `Registry` заражает код, распространяясь как вирус.
- объекты в `Registry` приходится добавлять в определенном порядке, иначе может оказаться, что какой-то из зависимостей объекта там еще нет.
- так как статические методы доступны из любой точки кода, мы не можем ограничить доступ к `Registry` только определенными классами

Этот паттерн применялся в Zend Framework 1: http://framework.zend.com/manual/1.12/ru/zend.registry.using.html

Если вы знаете, чем он хорош и где его стоит применять - напишите мне на почту (внизу) пожалуйста.

## Чем плох ServiceLocator

[ServiceLocator](http://sergeyteplyakov.blogspot.ru/2013/03/di-service-locator.html) - это объект, способный находить или создавать другие объекты (сервисы). Мы создаем объект `ServiceLocator`, заполняем его объектами (либо указываем, как их создавать), и передаем классу в конструктор, а класс может взять из него то, что ему требуется:

```php
$sl = new ServiceLocator;

$pdo = new PDO(...);
$sl->setPdo($pdo);

// передаем ServiceLocator, из которого UDG возьмет объект PDO
$userDataGateway = new UserDataGateway($sl);
$sl->setUserDataGateway($userDataGateway);
```

А вот, как он используется: 

```php
class UserDataGateway
{
    private $sl;

    public function __construct(ServiceLocator $sl)
    {
        $this->sl = $sl;
    }

    public function getUserById($id)
    {
        $pdo = $this->sl->getPdo();
        ...
```

Этот подход исправляет часть недостатков Registry (например, он доступен только в тех классах, куда мы его передали), но имеет такие недостатки: 

- зависимости класса не видны. Непонятно, какие сервисы должны быть добавлены в `ServiceLocator`
- `ServiceLocator` отравляет код и становится лишней зависимостью каждого класса

Однако, использование ServiceLocator иногда оправданно. В некоторых фреймворках объект ServiceLocator (в качестве которого выступает DI Container) передается в конструктор контроллера, чтобы тот мог найти и вызвать нужные ему сервисы. Это проще, чем передавать каждый по отдельности в конструктор. Контроллер является чем-то вроде стартовой точки обработки запроса, так что там это может быть приемлемо. 

Кстати, самой простой реализацией ServiceLocator может быть простой массив: 

```php
$serviceLocator = [];
// Добавление сервиса
$serviceLocator['service'] = new Service(...);
// Получение сервиса
$service = $serviceLocator['service'];
```

Но на мой взгляд, это плохо соответствует ООП и имеет недостатки: мы, например, не можем ставить тайп хинты на него. 

## Чем хорош DI container 

При использовании DI в небольшом приложении мы можем вручную создать все нужные объекты в самом начале: 

```php
$a = new A;
$b = new B($a);
$c = new C;
```

Но когда классов становится много, код усложняется. Мы должны создавать объекты в правильном порядке, и нам приходится создавать все объекты, даже если часть из них нам далее не понадобится. Для решения этой проблемы придуманы *DI контейнеры*. Это класс, отвечающий за создание нужных нам сервисов. Сначала мы описываем функции для создания каждого объекта, и после этого можем получать эти объекты из контейнера. Один из простых контейнеров - это [Pimple](http://pimple.sensiolabs.org/) (англ.). Вот пример кода с его использованием: 

```php
$container = new Pimple\Container;

// Описываем как создавать объект PDO
$container['pdo'] = function ($container) {
    return new PDO(...);
};

// Описываем как создать объект работы с БД, зависящий от PDO
$container['userDataGateway'] = function ($container) {
    return new UserDataGateway($container['pdo']);
};

// Получаем нужный нам объект
$udg = $container['userDataGateway'];
```

Как видно, объект контейнера позволяет работать с ним, используя синтаксис доступа к массиву (хотя он и не является массивом), за счет реализации интерфейса [ArrayAccess](http://php.net/manual/ru/class.arrayaccess.php).

DI container внешне напоминает ServiceLocator. Но если присмотреться, то между ними есть принципиальная разница: при использовании ServiceLocator все классы начинают зависеть от него. В случае же с DI container они о нем ничего не знают, и получают в конструктор только нужные им объекты. Потому DI container не имеет недостатков ServiceLocator. Ты можешь использовать DI контейнер с любыми классами. 

Заметь что контейнер — внешняя вещь по отношению к сервису. Мы не передаем сам контейнер в конструктор (иначе это будет `ServiceLocator`). Класс от него не зависит, мы можем в любой момент выкинуть контейнер и создать объект руками или взять другой контейнер от другого производителя. Мы можем описать в конфиге и создать несколько экземпляров класса с разными настройками. Ты чувствуешь силу ООП и зришь свет разума, падаван? 

Есть много реализаций DI container, например более сложный и мощный [Symfony DI Container](http://symfony.com/doc/current/components/dependency_injection/introduction.html) (англ.), где можно описывать зависимости классов в файлах конфигурации.

Некоторые контейнеры могут также автоматически находить нужные классу зависимости, например, по тайп-хинтам в конструкторе. Вот здесь описана [опция autowiring в Symfony](http://symfony.com/doc/current/components/dependency_injection/autowiring.html) (англ.).

В некоторых фреймворках, правда, объект DI container передается в контроллер (фактически получается паттерн ServiceLocator) вместо того, чтобы передавать явно только нужные контроллеру сервисы.

## Дополнительное чтение

Все эти штуки описал и разложил по полочкам Фаулер (он очень умный) в своей статье: http://www.martinfowler.com/articles/injection.html (англ.)
Переводы на русский: 

- http://www.argc-argv.com/4_2011/article01.pdf
- http://yugeon-dev.blogspot.ru/2010/07/inversion-of-control-containers-and_21.html

## Связаться с автором

> codedokode (あ) gmail.com
